迭代是通过重复执行的代码处理相似的数据集的过程，并且本次迭代的处理数据要依赖上一次的结果继续往下做，上一次产生的结果为下一次产生结果的初始状态，如果中途有任何停顿，都不能算是迭代。
：
集合数据类型，如list、tuple、dict、set、str等；
生成器(generator)，包括生成器和带yield的生成器函数。
在Python中，如果给定一个列表、元组、字符串…，我们可以通过for循环来遍历，这种遍历我们称为迭代（Iteration），如下所示：
输出结果：
可迭代对象需具有 
 方法，可迭代对象可以使用 for 循环遍历，我们导入
 模块，使用
 ，判断一个变量是否为可迭代对象返回
表明是可迭代对象；
则不是可迭代对象，具体判断方法如下：
输出结果：
迭代器是一个可以记住遍历的位置的对象。
迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
把一个类作为一个迭代器使用需要在类中实现两个方法 
 与 
 。
 方法返回对象本身，即：self
 方法返回下一个数据，如果没有数据了，就需要抛出一个
 异常
创建一个返回数字的迭代器，初始值为 1，逐步递增 1，在 5 次迭代后停止执行：
输出结果：
通过列表生成式，我们可以直接创建一个列表，但是受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表,不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。所以，如果列表元累可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的Iist，从而节省大量的空间。
 。生成器的这个特性，为解决无限个变量和有限内存之间矛盾的问题，提供了解决方案，或者为优化内存使用效率提供了途径
在函数内使用 
 关键字，每次调用函数类似于对迭代器执行 next() 方法，
要创建一个生成器，有很多种方法。第一种方法很简单，只要把一个列表生成式的
改成
输出结果：
创建L和G的区别仅在于最外层的
和
，L是一个列表，而G是一个生成器，我们可以直接打印出 L 的每一一个元素，但我们怎么打印出G的每一个元素呢？如果要-一个一个打印出来，可以通过
函数获得生成器的下一个返回值。
generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。
比如，著名的斐波拉契数列(Fibonacci) ， 除第一个和第二个数外，任意一个数都可由前两个数相加得到：
斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：
函数里有
，就变为生成器：
输出结果：
如上所示，我们可以看出
，当第一次调用
的时候，生成器从上往下执行，执行到
的时候停止并返回
的值；再次调用
的时候，程序根据原来停止的地方接着往下执行，循环执行到
的时候又停止并返回
的值。
在上面的例子，我们在循环过程中不断调用yield， 就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。同样的，把函数改成generator后，我们基本上从来不会用 next() 来获取下一个返回值，而是直接使用for循环来迭代，并且不需要关心 StopIteration 的错误：
输出结果：
但是用 for 循环调用generator时，发现拿不到generator的return语句的返回值，如果想要拿到返回值，必须捕获
错误，返回值包含在Stoplteration的value中：
输出结果：
输出结果：
可以看出使用生成器的耗时会更少，数字继续增大的话我们可以查看一下机器的内存，第一个列表推导式的方式大概率会内存爆掉，因为我们的生成器式是使用才迭代，只迭代一次不会存在内存中。所以内存会比较稳健的求出结果。
使用生成器的挂起并可重新在挂起点运行的特点，我们可以实现按需，每次读取指定大小的文件，避免因为读取文件时，因为一次性读取内容过多，导致内存溢出等问题
闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。
通俗来讲：比如我们调用一个带有返回值的函数 x，此时函数 x 为我们返回一个函数 y，这个函数 y 就被称作闭包，这么一说是不是豁然开朗了
输出结果：
可以看出来，我先调外面的函数传一个默认的 number 的值；用 ret 去指向返回内部函数的引用，接下来在用 ret 的时候就会在之前调用外面函数的基础上计算
装饰器，就是装修、装饰的意思，但是，不改变原有的程序功能。比如，我装修一个房子，如果不隔音，我在墙上加一层隔音板，却不能把墙拆了，换成隔音材质。
而程序中也是一样，不会对原来的函数造成改变，还要增添新的功能，调用函数时的接口没有变化。
比如，我们要在函数的基础上，增加一个程序效率检测功能，也就是记录函数执行的时间。
装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，所以这也是Python面试中必问的问题，但对于好多初次接触这个知识的人来讲，这个功能有点绕，自学时直接绕过去了，然后面试问到了就挂了，因为装饰器是程序开发的基础知识，这个都不会，别跟人家说你会Python，看了下面的文章，保证你学会装饰器
装饰器可以基于函数实现也可基于类实现，其使用方式基本是固定的，看一下基本步骤：
定义装饰函数（类）
定义业务函数
在业务函数上添加 
输出结果：
输出结果：
思路图如下：
 
从上可以看出
指向
就先打印
，
中的
指向
；调
就接着打印
,
中的
指向
…；所以
先等
调用完再调用，输出结果
。
：
输出结果：
从上可以看出，代码执行到
 就开始装饰了，我们并没有调用
都输出了
，我们调用的是装饰完后的结果。
：
输出结果：
从上可以看出，
在最上面，下面需要是一个函数，可下面是
，必须先等
装饰完再装饰，所以先输出
传递两个参数案例：
输出结果：
不定长参数案例：
输出结果：
输出结果：
输出结果:
输出结果：
：
：传递的参数不同，可以用于判断做不同的事情

        

    

                    

                    

                

                    

                    

                

                    

                    

                

                    

                    

                

                    

                    

                
请填写红包祝福语或标题
红包个数最小为10个
红包金额最低5元
打赏作者
无 羡ღ
你的鼓励将是我创作的最大动力
您的余额不足，请更换扫码支付或
抵扣说明：
 1.余额是钱包充值的虚拟货币，按照1:1的比例进行支付金额的抵扣。
 2.余额无法直接购买下载，可以购买VIP、C币套餐、付费专栏及课程。
